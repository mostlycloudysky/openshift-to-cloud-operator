package migrate

import (
	"context"
	"strings"

	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"

	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"sigs.k8s.io/yaml" // ðŸ‘ˆ for YAML marshaling

	migratev1 "github.com/mostlycloudysky/openshift-to-cloud-operator/api/migrate/v1"
)

// MigrationPlanReconciler reconciles a MigrationPlan object
type MigrationPlanReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

func toSet(items []string) map[string]bool {
	set := make(map[string]bool)
	for _, i := range items {
		set[strings.ToLower(i)] = true
	}
	return set
}

// normalizeForPortability removes cluster-specific fields
func normalizeForPortability(objs []client.Object) []client.Object {
	for _, obj := range objs {
		switch o := obj.(type) {
		case *corev1.Service:
			o.Spec.ClusterIP = ""
			o.Spec.ClusterIPs = nil
		case *corev1.PersistentVolumeClaim:
			o.Spec.VolumeName = ""
		case *networkingv1.Ingress:
			for i := range o.Spec.Rules {
				if o.Spec.Rules[i].HTTP == nil {
					continue
				}
				for j := range o.Spec.Rules[i].HTTP.Paths {
					port := &o.Spec.Rules[i].HTTP.Paths[j].Backend.Service.Port
					if port.Number == 0 && port.Name == "" {
						port.Number = 80
					}
				}
			}
		}
	}
	return objs
}

// +kubebuilder:rbac:groups=migrate.migrate.dev,resources=migrationplans,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=migrate.migrate.dev,resources=migrationplans/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=migrate.migrate.dev,resources=migrationplans/finalizers,verbs=update

func (r *MigrationPlanReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// 1. Fetch MigrationPlan
	var plan migratev1.MigrationPlan
	if err := r.Get(ctx, req.NamespacedName, &plan); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// 2. Defaults
	nsList := plan.Spec.Namespaces
	if len(nsList) == 0 {
		nsList = []string{req.Namespace}
	}
	outputName := plan.Spec.OutputConfigMap
	if outputName == "" {
		outputName = plan.Name + "-output"
	}

	// 3. Init
	found := map[string]int{}
	var notes []string
	var yamlDocs []string
	yamlDocs = append(yamlDocs, "# generated by openshift-to-cloud-operator")

	// NEW: collect raw objects instead of YAML
	var allObjs []client.Object

	// 4. Loop namespaces + include
	include := toSet(plan.Spec.Include)

	for _, ns := range nsList {
		if include["deploymentconfigs"] {
			objs, count, n := r.convertDeploymentConfigs(ctx, ns)
			allObjs = append(allObjs, objs...)
			found["deploymentconfigs"] += count
			notes = append(notes, n...)
		}
		if include["routes"] {
			objs, count, n := r.convertRoutes(ctx, ns, plan.Spec.IngressClass)
			allObjs = append(allObjs, objs...)
			found["routes"] += count
			notes = append(notes, n...)
		}
		if include["services"] {
			objs, count, n := r.convertServices(ctx, ns)
			allObjs = append(allObjs, objs...)
			found["services"] += count
			notes = append(notes, n...)
		}
		if include["pvcs"] || include["persistentvolumeclaims"] {
			objs, count, n := r.convertPVCs(ctx, ns, plan.Spec.TargetCloud)
			allObjs = append(allObjs, objs...)
			found["persistentvolumeclaims"] += count
			notes = append(notes, n...)
		}
	}

	// 5. Normalize and marshal to YAML
	cleanObjs := normalizeForPortability(allObjs)
	for _, obj := range cleanObjs {
		y, err := yaml.Marshal(obj)
		if err != nil {
			log.Error(err, "failed to marshal object", "obj", obj)
			continue
		}
		yamlDocs = append(yamlDocs, string(y))
	}

	// 6. Write ConfigMap
	cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{
		Name:      outputName,
		Namespace: req.Namespace,
	}}
	if _, err := controllerutil.CreateOrUpdate(ctx, r.Client, cm, func() error {
		if cm.Data == nil {
			cm.Data = map[string]string{}
		}
		cm.Data["converted.yaml"] = strings.Join(yamlDocs, "\n---\n")
		return nil
	}); err != nil {
		log.Error(err, "failed to create/update ConfigMap")
		return ctrl.Result{}, err
	}

	// 7. Update Status
	plan.Status.Phase = "Generated"
	plan.Status.Found = found
	plan.Status.Notes = notes
	plan.Status.Output = outputName
	if err := r.Status().Update(ctx, &plan); err != nil {
		log.Error(err, "failed to update status")
		return ctrl.Result{}, err
	}

	log.Info("MigrationPlan processed", "name", req.NamespacedName)
	return ctrl.Result{}, nil
}

func (r *MigrationPlanReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&migratev1.MigrationPlan{}).
		Named("migrate-migrationplan").
		Complete(r)
}
